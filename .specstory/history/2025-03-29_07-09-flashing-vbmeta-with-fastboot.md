<!-- Generated by SpecStory -->

# Flashing vbmeta with Fastboot (2025-03-29 00:09:57)

_**User**_

fastboot flash --disable-verity --disable-verification vbmeta vbmeta.img

---

_**Assistant**_



---

This command uses the fastboot utility to flash a vbmeta image to an Android device while disabling both verity and verification.

Here's what it does:
- Flashes the vbmeta.img file to the vbmeta partition
- Disables dm-verity (which verifies integrity of device partitions)
- Disables Android Verified Boot verification checks

This is typically used during Android development to allow custom ROMs, modified system partitions, or to enable root access on devices.

Do you want me to help you execute this command or explain more about its implications?

---

_**User**_

yes but for recovery img

---

_**Assistant**_



---

To flash a recovery image using fastboot:

```
fastboot flash recovery recovery.img
```

If you also want to disable verified boot protection (similar to what you did with vbmeta), you'll need to:

1. Flash the recovery image:
   ```
   fastboot flash recovery recovery.img
   ```

2. Flash the vbmeta with verification disabled:
   ```
   fastboot flash vbmeta vbmeta.img --disable-verity --disable-verification
   ```

The recovery partition itself doesn't take the verification flags directly - those apply to the vbmeta partition which controls Android's Verified Boot system.

---

_**User**_

cpio -idm < ../ramdisk.cpio

---

_**Assistant**_



---

This command extracts the contents of a ramdisk.cpio file into the current directory:

- `-i`: Extract/unpack mode
- `-d`: Create directories as needed during extraction
- `-m`: Preserve file modification times

You're using this to unpack the ramdisk portion of an Android boot or recovery image. This is a common step when modifying Android boot images, allowing you to edit the ramdisk contents before repacking.

Make sure you're in the directory where you want the contents extracted before running this command.

---

_**User**_

?

---

_**Assistant**_



---

The error shows that the file `../ramdisk.cpio` doesn't exist in the parent directory.

You're trying to extract a ramdisk, but you need to:

1. Make sure you have a boot or recovery image unpacked first
2. Check that the ramdisk.cpio was generated and its correct location

Typically with AIK-Linux, you would:
1. First unpack the image: `./unpackimg.sh your_recovery.img`
2. This creates a "split_img" and "ramdisk" directory
3. The ramdisk files would be in the ramdisk directory, not as a cpio file

Check if you've already unpacked an image, or if the ramdisk file is in a different location than you expected.

---

_**User**_

@fastboot-patcher sudo ./patcher
[patcher.sh](info) -> [found lz4-zipped image! unzipping...]
using blocks of size 1024 KB 
Decoding file /Users/chris/Desktop/Firmware/FP/fastboot-patcher/recovery.img 
/Users/chris/Desktop/Firmware/ : decoded 38797312 bytes                        
[patcher.sh](success) -> [unzipped to raw.img!]
[patcher.sh](info) -> [editing image...]
dd: unknown iflag count_bytes
[patcher.sh](info) -> [making keyfile...]
[patcher.sh](warning) => {fragmenting image for patching!}
No such file or directory (os error 2)
[patcher.sh](warning) => {patching fragments (16)}
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
No such file or directory (os error 2)
Failed to process cpio
[patcher.sh](success) -> [successfully finished patch to fragmented image!]
[patcher.sh](warning) => {attempting to defragment image! if your image is corrupted, this may not end well...}
No such file or directory (os error 2)
[patcher.sh](error) => {failed to assemble image!}

---

_**Assistant**_



---

The patcher script is failing due to compatibility issues with macOS. Several problems are visible:

1. `dd` command flag incompatibility: `unknown iflag count_bytes`
2. Multiple file not found errors 
3. CPIO processing failure
4. Image assembly failure

The script was likely designed for Linux and isn't fully compatible with macOS. Let's fix this:

1. First, let's examine the patcher script to understand what it's trying to do

---

Could not find file 'patcher'. Did you mean one of:
- FP/fastboot-patcher/patcher
- FP/fastboot-patcher/patcher-minimal
- FP/fastboot-patcher/avbtool

---

Read file: FP/fastboot-patcher/patcher

---

Now let's check the minimal version to see if it might be more compatible:

---

Read file: FP/fastboot-patcher/patcher-minimal

---

Let's create a macOS-compatible version of the patcher:

---

```diff
- 
+ #!/bin/bash
+ #####=============== SMALLRAT TOOLBOX (MACOS VERSION) ===============#####
+ function message() {
+    case $1 in
+    "error") echo "[patcher.sh](error) => {$2}";;
+    "warning") echo "[patcher.sh](warning) => {$2}";;
+    "success") echo "[patcher.sh](success) -> [$2]";;
+    "info") echo "[patcher.sh](info) -> [$2]";;
+    *) return 1;;
+    esac
+ }
+ 
+ function check_exists() {
+    if [ -e "$1" ]; then
+       found=true
+       eval "$2"
+    else
+       found=false
+       eval "$3"
+    fi
+ }
+ 
+ csd=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &> /dev/null && pwd)
+ pass=":"
+ 
+ # Check for required tools
+ if ! command -v python3 &> /dev/null; then
+     message error "python3 not found, please install it"
+     exit 1
+ fi
+ 
+ # unzip or rename if necessary
+ check_exists "$csd/recovery.img.lz4" "$pass" "$pass"
+ if [ $found == true ]; then
+    message info "found lz4-zipped image! unzipping..."
+    if command -v lz4 &> /dev/null; then
+       lz4 -B6 --content-size -f "$csd/recovery.img.lz4" && mv ./recovery.img ./raw.img &&
+       message success "unzipped to raw.img!"
+    else
+       message error "lz4 not found. Please install it with: brew install lz4"
+       exit 1
+    fi
+ else 
+    check_exists "$csd/recovery.img" "$pass" "$pass"
+    if [ $found == true ]; then
+       mv "$csd/recovery.img" "$csd/raw.img" &&
+       message success "found unzipped image!"
+    else 
+       message error "no image to patch found. please place recovery.img.lz4 or recovery.img in folder" 
+       exit 1
+    fi
+ fi
+ 
+ # edit raw image
+ message info "editing image..."
+ off=$(grep -ab -o SEANDROIDENFORCE raw.img | tail -n 1 | cut -d : -f 1)
+ if [ -z "$off" ]; then
+    message warning "SEANDROIDENFORCE not found, using entire image"
+    cp raw.img header.img
+ else
+    # MacOS dd doesn't support iflag=count_bytes, using a different approach
+    dd if=raw.img of=header.img bs=1 count="$off"
+    message success "made edit to image!"
+ fi
+ 
+ # make key/signature
+ check_exists "$csd/keys" ":" "mkdir -p $csd/keys"
+ message info "making keyfile..."
+ check_exists "$csd/keys/phh.pem" ":" "openssl genrsa -f4 -out $csd/keys/phh.pem 4096 && message success 'made phh.pem'"
+ 
+ # fragment the edited image
+ check_exists "$csd/fragments" ":" "mkdir -p $csd/fragments"
+ # Ensure fragments directory exists and is empty
+ rm -rf "$csd/fragments"/*
+ mkdir -p "$csd/fragments"
+ cd "$csd/fragments" || { message error "Could not enter fragments directory"; exit 1; }
+ 
+ message warning "fragmenting image for patching!"
+ # Run magiskboot to unpack the image
+ "$csd/magiskboot" unpack "$csd/header.img" || { message error "Failed to unpack image"; exit 1; }
+ "$csd/magiskboot" cpio ramdisk.cpio extract || { message error "Failed to extract cpio"; exit 1; }
+ 
+ # Verify we have the recovery file
+ check_exists "$csd/fragments/system/bin/recovery" "message success successfully fragmented image!" "message error fragmentation failed! && exit 1"
+ 
+ # patch the fragmented image
+ message warning "patching fragments (16)"
+ 
+ # Make sure the directory structure is correct
+ mkdir -p "$csd/fragments/system/bin" 2>/dev/null
+ 
+ # Do the hex patches
+ "$csd/magiskboot" hexpatch system/bin/recovery e10313aaf40300aa6ecc009420010034 e10313aaf40300aa6ecc0094 &&
+ message success 'finished (1)' # 20 01 00 35
+ "$csd/magiskboot" hexpatch system/bin/recovery eec3009420010034 eec3009420010035 &&
+ message success 'finished (2)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 3ad3009420010034 3ad3009420010035 &&
+ message success 'finished (3)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 50c0009420010034 50c0009420010035 &&
+ message success 'finished (4)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 080109aae80000b4 080109aae80000b5 &&
+ message success 'finished (5)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 20f0a6ef38b1681c 20f0a6ef38b9681c &&
+ message success 'finished (6)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 23f03aed38b1681c 23f03aed38b9681c &&
+ message success 'finished (7)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 20f09eef38b1681c 20f09eef38b9681c &&
+ message success 'finished (8)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 26f0ceec30b1681c 26f0ceec30b9681c &&
+ message success 'finished (9)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 24f0fcee30b1681c 24f0fcee30b9681c &&
+ message success 'finished (10)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 27f02eeb30b1681c 27f02eeb30b9681c &&
+ message success 'finished (11)'
+ "$csd/magiskboot" hexpatch system/bin/recovery b4f082ee28b1701c b4f082ee28b970c1 &&
+ message success 'finished (12)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 9ef0f4ec28b1701c 9ef0f4ec28b9701c &&
+ message success 'finished (13)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 9ef00ced28b1701c 9ef00ced28b9701c &&
+ message success 'finished (14)'
+ "$csd/magiskboot" hexpatch system/bin/recovery 2001597ae0000054 2001597ae1000054 && # ccmp w9, w25, #0, eq ; b.e #0x20 ===> b.ne #0x20
+ message success 'finished (15)'
+ 
+ # Need to be careful with quotes in cpio command
+ "$csd/magiskboot" cpio ramdisk.cpio "add 0755 system/bin/recovery system/bin/recovery" &&
+ message success 'finished (16)'
+ message success "successfully finished patch to fragmented image!"
+ 
+ # reassemble fragmented image
+ message warning "attempting to defragment image! if your image is corrupted, this may not end well..."
+ "$csd/magiskboot" repack "$csd/header.img" "$csd/output.img" || { message error "Failed to repack image"; exit 1; }
+ 
+ check_exists "$csd/output.img" "message success 'assembled output.img!' && cd $csd" "message error 'failed to assemble image!' && exit 1"
+ 
+ # sign patched image with keyfile
+ message info "extracting public key to phh.pub.bin..."
+ python3 "$csd/avbtool" extract_public_key --key "$csd/keys/phh.pem" --output "$csd/keys/phh.pub.bin" &&
+ message info "signing patched image with key..."
+ python3 "$csd/avbtool" add_hash_footer --image "$csd/output.img" --partition_name recovery --partition_size $(wc -c < "$csd/raw.img") --key "$csd/keys/phh.pem" --algorithm SHA256_RSA4096 &&
+ message success "signed image successfully!"
+ 
+ # package image for use in odin
+ message info "packaging image for odin..."
+ tar -cvf "$csd/output.tar" "$csd/output.img" &&
+ message success "successfully packaged output.img -> output.tar"
+ 
+ # Report success
+ message success "patched recovery image created as output.img and output.tar"
+ message success "Use 'fastboot flash recovery output.img' to flash to your device"
+ message success "Don't forget to also run 'fastboot flash vbmeta vbmeta.img --disable-verity --disable-verification'" 
```

---

Now let's make the new script executable:

---

Cancelled

---



---



---

